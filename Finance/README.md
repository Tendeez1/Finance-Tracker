# FINANCE TRACKER
#### Video Demo: (https://www.youtube.com/watch?v=v4a-K0LCVR8&ab_channel=TommyPham)
#### Description:
Since I am living alone and also going into my specialization of Computer Engineering this year, I thought it would be a good idea to create a finance tracker using C language as well as techniques I learn from practicing SQL in this course. This programs would require you to register for an account, with a proper first, last name and username. A 4 digit pin is used as the password. Furthermore, you can login using your username as well as the pin you created. Once login, you can either update your expenses, income, or view your statistics. Statistics will display your previous month income/expenses as well as this month's.

Now let explain the code, the first file created was the finances SQL file, this file contains the code to create the table. The first table "user" contains all the personal information such as names, username, password, etc. It also contains a column call finance_id which links it with other tables. The next two tables are called "finance" and "old_finance", which stores current data as well as previous data. These SQL tables will then be saved to a database file called database.db.

The next file is functions_db.c, which is where all the necessary functions are kept. The first function insert_user is responsible for inserting the value that user inputs during the register screen. In the function, we create a pointer to the database file, and then we call an sqlite3 function sqlite3_open, which is responsible for opening the database file for us to use. In the many
upcoming lines of codes that consist of if statements checking for SQLITE_OK or SQLITE_DONE, these are error handling. For example, after opening we want to check if the opening process was successful which we can use SQLITE_OK for. Next we define a query so we can execute it, which is done using const char *(name). With the sqlite3_prepare_v2 function, there are 4 parameters, first is the database, second is the SQL statement, third is the length of SQL string, and last is the pointer were the statement will be stored which is created from sqlite3_stmt *stmt. Next we can bind any placeholders with actual values. Lastly, we can execute that prepared statement with sqlite3_step(stmt) and once again we use SQLITE_DONE to catch any errors. Then we can finalize to deallocate memory and lastly close the database. This process will be repeated in different manners with the other functions.

The insert_finance function just place then newly registered users with a value of 0,0 for expenses and income. As well as retrieve and store the user id into finance_id. We can do that by taking the newly made row id by using sqlite3_last_insert_rowid(db) and then we can save into finance_id. The next function is statistics, which selects both the last month and current month financial details and then printing it into the terminal.

The next 2 functions are responsible for updating the income/expenses as well as placing our current details into the old_finance table before updating. The functions will ask the user for a float input. The functions will open the database, fetch the financial details from the current table where the id matches, the next code will check if the finance_id actually exist in the old_finance table or not then it will place the old financial detail until the row where the finance ID matches. If not then it will create a row and place it there. Then after we can use similar process as the other functions so we update the table with new input values. As well, after completed insert and update we have to deallocate the memory of stmt.

The login function is quite symbol, it just opens the database and checks if the input username and pin code is in the same row. This will just check if its correct or not and then return SQLITE_OK which we can use later. The next function will call make_user will be the one that is responsible for asking the user to input all the values and then also inserting the finance_id into the table. Then we re call insert_user to insert all the values inside.

Finally the last two functions are just used to create the "GUI" on the terminal for the user to use. The main problem that I was having with this code, is that the process of accessing the SQL tables and logic wise was much difficult compared to python.

And then the final step is just to place all those functions inside the main function. Which contains two switch cases, that will check for the first initial choice to login, register or exit. Then the second choice in the second switch case, to check what they want to do after logging in.
